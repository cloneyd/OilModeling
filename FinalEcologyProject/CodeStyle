Общие вопросы:
1)  Структура класса задана в отдельном файле
2)  Ключевые слова, используемые в комментариях:
// FIXME: - здесь содержится ошибка и ее описание, должно быть исправлено
// WARNING: - здесь содержится небезопасный участок кода, должно быть пересмотренно и заменено (если возможно)
// TODO: - незаконченная часть, описание, что должно быть сделано
По данным ключевым словам можно осуществлять поиск

Дополнительно по классам:
    Конструкторы, принимающие один явный параметр, по максимуму должны быть explicit

Заголовочные файлы:
1)  Header - files должны иметь расширение .hpp
2)  Расположение файлов при подключении следующее
    #include <AnyFileFromQt>
    // PASS
    #include <AnyFileFromStd>
    // PASS
    #include "AnyHandMadeFile>
    //PASS
    // Your code is started here

Файлы реализации:
1)  Порядок функций должен быть таким же, как и в заголовочном файле
2)  Функции должны быть разбиты по блокам (между блоками 2 отступа, между функциями - 1 отступ)
3)  Блоки должны быть подписаны(например, блок сеттеров - // setters, блок слотов - //accessMode slots, где accessMode - private, public, protected

3) Структуры заголовочного файла:
    Каждый файл должен иметь ifdef guard или pragma once
    Каждый файл должен содержать не более одного внешнего интерфейса


Функции:
1)  Наименование по следующему принципу:
    ReturnType(*&) firstSecondThird...(type first_input_arg, type second_input_arg..., type first_output_arg,..., type first_input_default arg...)
    ПРИМЕЧАНИЕ: * или & в возвращаемом типе ставятся к типу, а не к названию функции
2)  Если функция может вернуть некорректное значение, генерируем исключение, при этом ставим префикс us(unsafe) у функции (пример: usFoo(...)) (крайний случай)
3)  Nullptr (или его аналог) НЕ ВОЗВРАЩАТЬ
4)  Если пришли некорректные данные, то мы выводим сообщение об ошибке, данные скипаем и ставим в них невалидное значение (например, если каким - то чудом введена буква в таблицу,
в которой должны храниться только числа, то по этому значению ставим "-1", а само значение скипаем, НО ЭТО ДОЛЖНО БЫТЬ ПОФИКШЕНО)
5)  На функции должны быть максимально навешаны спецификаторы (inline, const, constexpr, noexcept). ЕСЛИ ЧТО - ТО МОЖНО ПОМЕТИТЬ СПЕЦИФИКАТОРОМ, ОНО ДОЛЖНО БЫТЬ ПОМЕЧЕНО.
6)  Gettеrs, которые могут вернуть ИЗМЕНЯЕМОЕ ЗНАЧЕНИЕ, должны быть помечены ключевым словом release и вернуть rvalue ссылку. В противном случае, мы возвращаем const lvalueref иъ
помечаем функцию getNameOfEntity
6)  Setters помечаются ключевым словом setNameOfEnyity
7)  Слоты должны быть подписаны в комментариях (с чем соединены)
// ПРИМЕЧЕНИЕ: я думаю, что нам стоит составить основной список обязательных сигналов

Константы:
    Если константы относятся к глобальной области видимости, то они должны быть в namespace. Если же константы являются константами статуса (типа, или прочее), например, WaterObjectType,
то они должны быть в enum class. Обычный enum не стоит использовать, только если нет явной нужды в implicit conversitions
    Если константы используются в нескольких файлах, то их стоит вынести в отдельный заголовочный файл, положить в namespace и сделать inline

Переменные:
    Данные членов класса должны иметь префикс m_ (пример названия: m_data).
    Глобальные переменные должны иметь префикс g_ (пример названия: g_pi);
    Переменные флагов должны иметь суффикс _flag (пример названия: is_deleted_flag)
    Несколько слов отделяются при помощи нижнего подчеркивания: first_second_third
    Ограничений на длину названия нет, но не стоит делать их слишком длинными, лучше сократить, но с сохранением смысла

Препроцессор:
    АХТУНГ!!! НЕ СТОИТ ИСПОЛЬЗОВАТЬ ПРЕПРОЦЕССОР БЕЗ ОСОБОЙ НЕОБХОДИМОСТИ!!! ОСОБЕННО ДЛЯ КОНСТАНТ!
    Возможные использования препроцессора:
1)  Использование подстановок (#define FOO(x) ((x) * (x)))
    ОБЯЗАТЕЛЬНО ИСПОЛЬЗОВАТЬ #undef FOO после завершения работы с данным #define!!!
2)  ifdef guard
3)  Условная компиляция (только там, где невозможно использовать if constexpr)
4)  ВСЕ ВЫРАЖЕНИЕ В МАКРОСАХ ВЫДЕЛЯЮТСЯ В СКОБОЧКИ (пример под цифрой 1)

Исключения:
    АХТУНГ!!! НЕ СТОИТ ИСПОЛЬЗОВАТЬ ИСКЛЮЧЕНИЯ БЕЗ ОСОБОЙ НЕОБХОДИМОСТИ!!
    Все функции должны давать strong exeption guarantee (если используются функции из стандартной библиотеки, которые могут кинуть исключения, они должны быть обработаны вами, ничего не должно упасть)
    Если какая - либо из функций может кинуть исключение, ОНА ДОЛЖНА БЫТЬ ПОДПИСАНА.
    Исключения не приветствуются (придется доказывать, зачем кидаете)

UI:
    Требования по названию функций и переменных относятся и к UI!

ЕСЛИ ОСТАЛИСЬ ВОПРОСЫ - ОБГОВАРИВАЕМ!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! (больше знаков богу знаков)
